haklog is a functional dialect of prolog without the cut.

a quick overview of the differences: 

classic prolog example:

    member(X,[X|_]).
    member(X,[_|T]) :- member(X,T).

the same in haklog:

    member x x,_:;
    member x _,t :- member x t

prolog   vs     haklog
[H|T]           h,t
[1,2,3]         [1 2 3]
atom            'atom
Variable        variable/Variable
_               _
X is 1+2        x = {1+2}
X = 1 + 2       x = 1+2
foo(X,Y)        foo x y
predicates      functions
!               n/a
foo.            foo :;
foo :- bar      foo :- bar
foo, bar        foo && bar
foo, !, bar     foo and bar   {foo; bar}
foo ; bar       foo || bar   
(foo,!); bar    foo or bar
foo -> bar      foo -> bar
                if (foo -> bar)* expr
fail            fail
member(X,Y)     X in Y
write           say

findall(X,foo(X),L)
                L = every foo x
call(X)         eval x

a rough overview of the syntax - check parser.pl for specifics 

haklog is like prolog in that arguments are not evaluated, but variables
are bound before  unifying.

foo x y z    call the function foo with x y and z
foo 1+2      call the function foo with the structure '1+2'

i.e. unification.

here is an example block:

foo x y :- {
    z = {bar x}
    x * 2
}

(foo 1 2 3) and foo(1 2 3) are perfectly good ways to call a function too.

{}' are code. {}'s can have spaces,newlines or ; seperating statements. 
same for []'s -lists
()'s can only contain one statement

here is a list: [1 2 3 4] if I call 
foo [1+2 3+4], it recieves  a list containing 1+2 3+4
again, like prolog x = [1+2 3+4] also does not evaluate arguments.

so: 1+2 - expression, evaluated
x = 1+2 - unification, 1+2 is not evaluated
foo 1+2 - unification again
foo {1+2} - explicit expression, evaluated.

a little note:
foo followed by items is a function call
foo on it's own is a variable.

x + y is x, y variables
x + y 1 2 3 is the list (x+y) 1 2 3
x + foo(y) or x + (foo y) foo is evaluated
foo bar(y) - unification does not evaluate bar(y).

` is the built in eval function, and calling x = 1+2; eval x returns 3
to escape evaluation in unification, use {}'s, not `

here is another example: append

append [] x :- x
append h,t x :- h,{append t x}

(warning, although things like
[1 2 3 4] = {append x [3 4]}
works, it doesn't work efficiently)

if you load eval into swi prolog, you can get a semi repl:

?- exec("1 or 2 or 3",Env,Res).
Env = [],
Res = 1 ;
Env = [],
Res = 2 ;
Env = [],
Res = 3 ;
false.

closures work:
foo x :- (bar :- x) 
(foo x)()

anonymous functions are declared using _ i.e _ x :- x


todo: less bugs, more documentation, less code.

possible language features:
    string handling: pattern matching over strings, variable capture, dcg akin?
    icon combinatorics? ++ backtracking append
    aggregate operators  3 + list is  {every (X in list && 3 + X)}
    string operations ? more sugar ? case statements? 
    message passing? erlang-like concurrency ? modules ? libraries?
    i/o ? difference lists? pegs? dcgs?
    mutable assignment?
    xml literals? url literals?


idea:

source = pattern , pattern 

"abc" = "a","b","c", 
X = Z ? /a/, A ? /c/ , D ?/c/.

