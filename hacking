done:
    case statements? 
    if statements
    xor
    closures
    anonymous functions 
    foo() syntax
    y combinator
    maybe, $ call syntax
    make unify return value, avoid pattern in value
    partial pretty printer 
    strings are lists
    patterns in strings
    regex character classes and ranges
    ++ is append
    pattern composition
    == is equality does not instanciate variables
    x^l is x* , l = length(x)
    x^? is the non greedy version
    x is y 
    moved patterns into own operator =~ out of =
    moved reserved words into parser.
    standard library for lists/functions
    aggregate operators  3 + list is  {every (X in list && 3 + X)}
    simple file i/o  
    message passingr,? erlang-like concurrency 
    numerical ranges with ..
    2 ** 3
    make 3+4 work
next:

    range matches 0,1 1: 3..4
    := ?
    add ==~
    [] lookup foo[fofo]
     foo[a[b]] is z=  foo[a] and z[b]; z maybe x / 'foo / 'y hmmm -> 'foo->l in x ;'y->v in l; v  
    string interpolation, """ """ strings
bugs:

housekeeping:
    pretty printer
    repl - seperate thread using mutex for locks or breaks
    prelude ?

data structures:
    mutable variables
    meta-types? classes/objects? alternatively meta lists - things with list semantics + others

possible language features:
    modules ? libraries? perl like package declaration, python like modules from import import

syntax:
    xml literals? url literals?
    xpath ?

--
pattern matching.

peg operators;

postfix:
*           kleene star     any
+                           some
    {m,n}
    up to n
?                           maybe
*?                          anyz
+?                          somez    
??                          maybez

prefix:
! isnt  negative lookahead
& ahead positive lookahead

message passing/processes:
    send X blah blah blah
    recv x 1 -> 2 3 ->4
    spawn

strings:
    string replacement ?
    uses prolog native strings.
    need to turn concat into a stream operator
    alternatively: treat append like cons, strings like lists

    "foo ${} $a"
    """ fooo foo
    foo foo"

    regexes?
    /foo bar /

