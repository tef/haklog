done:
    case statements? 
    if statements
    xor
    closures
    anonymous functions 
    foo() syntax
    y combinator
    maybe, $ call syntax
    make unify return value, avoid pattern in value
    partial pretty printer 

bugs:
    iron out bugs in unification 


housekeeping:
    pretty printer

data structures:
    string handling: pattern matching over strings, variable capture, dcg akin?
    strings, "foo" , string patterns
    string operations ? more sugar ? 
     x = /\w+ \d+/
    icon combinatorics? ++ backtracking append
    
    mutable variables
    meta-types? classes/objects? alternatively meta lists - things with list semantics + others


possible language features:
    aggregate operators  3 + list is  {every (X in list && 3 + X)}
    message passing? erlang-like concurrency ? modules ? libraries?
    i/o ? 

syntax:
    xml literals? url literals?
    range matches 0,1 1: 3..4
    [] lookup foo[fofo] 
    xpath ?

--
pattern matching.

peg operators;

postfix:
*           kleene star     any
+                           some
    {m,n}
    up to n
?                           maybe
*?                          anyz
+?                          somez    
??                          maybez

prefix:
! isnt  negative lookahead
& ahead positive lookahead

message passing/processes:

send X blah blah blah

recv x 1 -> 2 3 ->4

spawn



string ideas:

use prolog native strings.

need to turn concat into a stream operator


alternatively: treat append like cons, strings like lists

magic cons as "aa" ++ x would treat x like a char and x* as a string, but "aa" ++ "bb" would be automa
tically "aabb"

iterable(L,H,T) :- L = [H|T].


"foo ${} $a"
""" fooo foo
foo foo"

regexes?
/foo bar /

string replacement ?
:
