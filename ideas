possible language features:
    string handling: pattern matching over strings, variable capture, dcg akin?
    icon combinatorics? ++ backtracking append
    aggregate operators  3 + list is  {every (X in list && 3 + X)}
    string operations ? more sugar ? case statements? 
    message passing? erlang-like concurrency ? modules ? libraries?
    i/o ? difference lists? pegs? dcgs?
    mutable assignment?
    xml literals? url literals?


ideas:

evaluation context vs unification context 

need to always unify args before evaling, esp for 
apply



pattern matching.

unification needs some more fine tuning:

need peg style ops to indicate matching

akin to python's tuple unpacking
we have a cons, we need an embed/star operator
1 2 X* 4 -> 1,2,X0,X1,...,4
we also need greedy/non greedy operators.

problem - ambiguous grammar 
we also need a bind operator
i.e Z = X ? [1 2] or X = [1 2]:X
to unify against one and bind to the other. ? is nice, so 
:.

X = Z ? "a"*, A ? "b"* ,D ?/c/.
D = "abc"*

// <- string pattern syntax? with character classes

range matches 0,1 1: 3..4
lookahead ?

x?*


idea - build normal commands first range(x,0,1) range(x,0,1) etc

mutable variables - I have been thinking about
pure and impure functions when I should have been
thinking about mutable and immutable variables.

inessence: set x! 1 not set! x 1. Use ! to denote
a mutable variable.


